use std::str::FromStr;
use crate::tokens::*;

grammar;

pub Program: ProgramNode =
    <datasources:Datasource*>
    <tables:Table*>
    <functions:Function*> => ProgramNode { <> };

Datasource: DatasourceNode =
    <readonly_key:"readonly"?>
    "datasource" <name:QName> ";"
    => DatasourceNode {
        name,
        is_readonly: readonly_key.is_some(),
    };

Table: TableNode =
    "table" <name:ProperQName> "from" <datasource_name:QName>
    "{" <columns:Comma<TypedQName>> "}" => TableNode { <> };

Function: FunctionNode =
    "function" <name:QName>
    "(" <params:Comma<TypedQName>> ")"
    "->" <return_type:TypeNameWithVoid>
    "{" <body:Statement*> "}"
    => FunctionNode { <> };

Statement: StatementNode = {
    <VariableType> <QName> "<-" <Expression> ";" => StatementNode::VariableDefinition(<>),
    <QName> "<-" <Expression> ";" => StatementNode::Assignment(<>),
    <ConditionalStatement>,
    "while" <Expression> "{" <Statement*> "}" <("as" <QName> ";")?> => StatementNode::ConditionalLoop(<>),
    "return" <Expression?> ";" => StatementNode::Return(<>),
    "break" <QName?> ";" => StatementNode::Break(<>),
    "continue" <QName?> ";" => StatementNode::Continue(<>),
    <Expression> ";" => StatementNode::LoneExpression(<>)
}

ConditionalStatement: StatementNode =
    "if" <head:ConditionalBranch>
    <middle:("else" "if" <ConditionalBranch>)*>
    <else_body:("else" "{" <Statement*> "}")?>
=> {
    let mut branches = vec![head];
    branches.extend(middle.into_iter());
    StatementNode::Conditional(branches, else_body)
};

ConditionalBranch: ConditionalBranchNode =
    <condition:Expression> "{" <body:Statement*> "}" => ConditionalBranchNode { <> };

Expression: Box<ExpressionNode> = {
    #[precedence(level="0")]
    Int => Box::new(ExpressionNode::IntegerLiteral(<>)),
    Bool => Box::new(ExpressionNode::BoolLiteral(<>)),
    QLString => Box::new(ExpressionNode::StringLiteral(<>)),
    "(" <Expression> ")",
    <name:ProperQName?> "{" <fields:Comma<ColumnValue>> "}" => Box::new(ExpressionNode::Struct(<>)),
    "[" <Comma<Expression>> "]" => Box::new(ExpressionNode::Array(<>)),
    <Expression> "[" <Expression> "]" => Box::new(ExpressionNode::ArrayIndex(<>)),
    <Expression> "." <QName> "(" <Comma<Expression>> ")" => Box::new(ExpressionNode::MethodCall(<>)),
    <Expression> "." <QName> => Box::new(ExpressionNode::StructField(<>)),
    QName => Box::new(ExpressionNode::QName(<>)),
    #[precedence(level="1")] #[assoc(side="left")]
    <Expression> "+" <Expression> => Box::new(ExpressionNode::Add(<>)),
    <Expression> "-" <Expression> => Box::new(ExpressionNode::Subtract(<>)),
    <QName> "(" <Comma<Expression>> ")" => Box::new(ExpressionNode::FunctionCall(<>)),
    "query" "{" <Query> "}" => Box::new(ExpressionNode::Query(<>)),
    #[precedence(level="2")] #[assoc(side="left")]
    <Expression> ">" <Expression> => Box::new(ExpressionNode::Comparison(<>, ComparisonType::GreaterThan)),
    <Expression> "<" <Expression> => Box::new(ExpressionNode::Comparison(<>, ComparisonType::LessThan)),
    <Expression> ">=" <Expression> => Box::new(ExpressionNode::Comparison(<>, ComparisonType::GreaterThanOrEqual)),
    <Expression> "<=" <Expression> => Box::new(ExpressionNode::Comparison(<>, ComparisonType::LessThanOrEqual)),
    #[precedence(level="3")] #[assoc(side="left")]
    <Expression> "=" <Expression> => Box::new(ExpressionNode::Comparison(<>, ComparisonType::Equal)),
    <Expression> "!=" <Expression> => Box::new(ExpressionNode::Comparison(<>, ComparisonType::NotEqual))
}

ColumnValue: ColumnValueNode = <name:QName> ":" <value:Expression> => ColumnValueNode { <> };

// --- QUERIES ---

Query: QueryNode = {
    SelectQuery => QueryNode::Select(<>),
    InsertQuery => QueryNode::Insert(<>),
    DeleteQuery => QueryNode::Delete(<>),
    UpdateQuery => QueryNode::Update(<>)
}

SelectQuery: SelectQueryNode =
    "select" "from" <table_name:ProperQName>
    <where_clause:WhereClause?> => SelectQueryNode { <> };

WhereClause: WhereNode = "where" <column_name:QName> "=" <value:Expression> => WhereNode { <> };

InsertQuery: InsertQueryNode =
    "insert" <data_expr:Expression> "into" <table_name:ProperQName>
    => InsertQueryNode { <> };

DeleteQuery: DeleteQueryNode =
    "delete" "from" <table_name:ProperQName>
    <where_clause:WhereClause?> => DeleteQueryNode { <> };

UpdateQuery: UpdateQueryNode =
    "update" <table_name:ProperQName> "set"
    <assignments:NonEmptyComma<UpdateAssignment>>
    <where_clause:WhereClause?> => UpdateQueryNode { <> };

UpdateAssignment: UpdateAssignmentNode =
    <column_name:QName> "<-" <value_expr:Expression>
    => UpdateAssignmentNode { <> };

// --- MISCELLANEOUS ---

TypedQName: TypedQNameNode = <type_node:TypeName> <name:QName> => TypedQNameNode { <> };

VariableType: Option<TypeNode> = {
    "var" => None,
    <TypeName> => Some(<>)
}

TypeNameWithVoid: TypeNode = {
    <TypeName>,
    "void" => TypeNode::Void
}

TypeName: TypeNode = {
    "int" => TypeNode::Integer,
    "bool" => TypeNode::Bool,
    "str" => TypeNode::String,
    ProperQName => TypeNode::Struct(<>),
    <TypeName> "[" "]" => TypeNode::Array(Box::new(<>))
}

Int: i32 = r"-?[0-9]+" => i32::from_str(<>).unwrap();
Bool: bool = { "true" => true, "false" => false };
QLString: String = <s:r#""[^"]*""#> => s[1..s.len()-1].to_string();

ProperQName: String = r"_*[A-Z][a-zA-Z0-9]*" => String::from(<>);
QName: String = r"_*[a-z][a-zA-Z0-9_]*" => String::from(<>);

Comma<T>: Vec<T> = NonEmptyComma<T>? => match <> {
    Some(xs) => xs,
    None => vec![]
};

NonEmptyComma<T>: Vec<T> = <head:T> <tail:("," <T>)*> => {
    let mut vals = vec![head];
    vals.extend(tail.into_iter());
    vals
};
